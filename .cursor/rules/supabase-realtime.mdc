---
description: 
globs: 
alwaysApply: true
---
# Supabase Realtime Best Practices

## Overview
Supabase Realtime provides three core features: Broadcast (low-latency messaging), Presence (shared state tracking), and Postgres Changes (database change listeners). For Grind Quest, we'll primarily use Broadcast for chat and Presence for cursor tracking.

## Setup and Configuration

### Client Setup
```tsx
// lib/supabase/realtime.ts
import { createClient } from '@/lib/supabase/client'
import { RealtimeChannel } from '@supabase/supabase-js'

export function createRealtimeClient() {
  const supabase = createClient()
  
  return {
    supabase,
    createChannel: (channelName: string) => 
      supabase.channel(channelName, {
        config: {
          broadcast: { self: true }, // Include own messages
          presence: { key: '' } // Auto-generate presence key
        }
      })
  }
}
```

### Environment Variables
```env
# Already configured in project
NEXT_PUBLIC_SUPABASE_URL=your-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
```

## Presence System (Floating Heads)

### Presence Hook
```tsx
// hooks/usePresence.ts
'use client'

import { useEffect, useState } from 'react'
import { createRealtimeClient } from '@/lib/supabase/realtime'
import type { RealtimeChannel } from '@supabase/supabase-js'

interface UserPresence {
  user_id: string
  username: string
  avatar: string
  cursor_x: number
  cursor_y: number
  last_seen: string
}

export function usePresence(roomId: string = 'main') {
  const [presences, setPresences] = useState<Record<string, UserPresence>>({})
  const [channel, setChannel] = useState<RealtimeChannel | null>(null)
  
  useEffect(() => {
    const { createChannel } = createRealtimeClient()
    const newChannel = createChannel(`presence:${roomId}`)
    
    newChannel
      .on('presence', { event: 'sync' }, () => {
        const state = newChannel.presenceState()
        setPresences(state)
      })
      .on('presence', { event: 'join' }, ({ key, newPresences }) => {
        setPresences(prev => ({ ...prev, [key]: newPresences[0] }))
      })
      .on('presence', { event: 'leave' }, ({ key }) => {
        setPresences(prev => {
          const updated = { ...prev }
          delete updated[key]
          return updated
        })
      })
      .subscribe()
    
    setChannel(newChannel)
    
    return () => {
      newChannel.unsubscribe()
    }
  }, [roomId])
  
  const updatePresence = (data: Partial<UserPresence>) => {
    if (channel) {
      channel.track(data)
    }
  }
  
  return { presences, updatePresence }
}
```

### Cursor Tracking
```tsx
// components/features/CursorTracker.tsx
'use client'

import { useEffect } from 'react'
import { usePresence } from '@/hooks/usePresence'
import { useUser } from '@/hooks/useUser'
import { throttle } from 'lodash'

export function CursorTracker() {
  const { user } = useUser()
  const { updatePresence } = usePresence()
  
  useEffect(() => {
    if (!user) return
    
    const handleMouseMove = throttle((e: MouseEvent) => {
      updatePresence({
        user_id: user.id,
        username: user.username,
        avatar: user.avatar,
        cursor_x: e.clientX,
        cursor_y: e.clientY,
        last_seen: new Date().toISOString()
      })
    }, 100) // Throttle to 10fps
    
    document.addEventListener('mousemove', handleMouseMove)
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove)
      handleMouseMove.cancel()
    }
  }, [user, updatePresence])
  
  return null // This component doesn't render anything
}
```

### Floating Heads Display
```tsx
// components/features/FloatingHeads.tsx
'use client'

import { usePresence } from '@/hooks/usePresence'
import { useUser } from '@/hooks/useUser'
import { Avatar, AvatarImage, AvatarFallback } from '@/components/ui/avatar'
import { motion, AnimatePresence } from 'framer-motion'

export function FloatingHeads() {
  const { presences } = usePresence()
  const { user } = useUser()
  
  // Filter out current user
  const otherUsers = Object.values(presences).filter(
    presence => presence.user_id !== user?.id
  )
  
  return (
    <div className="fixed inset-0 pointer-events-none z-50">
      <AnimatePresence>
        {otherUsers.map((presence) => (
          <motion.div
            key={presence.user_id}
            initial={{ opacity: 0, scale: 0.5 }}
            animate={{ 
              opacity: 1, 
              scale: 1,
              x: presence.cursor_x - 20, // Offset for avatar center
              y: presence.cursor_y - 20
            }}
            exit={{ opacity: 0, scale: 0.5 }}
            transition={{ type: "spring", damping: 30, stiffness: 300 }}
            className="absolute"
          >
            <div className="relative">
              <Avatar className="w-10 h-10 border-2 border-primary shadow-lg">
                <AvatarImage src={presence.avatar} />
                <AvatarFallback>{presence.username[0]}</AvatarFallback>
              </Avatar>
              <div className="absolute -bottom-6 left-1/2 transform -translate-x-1/2">
                <div className="bg-black/80 text-white text-xs px-2 py-1 rounded whitespace-nowrap">
                  @{presence.username}
                </div>
              </div>
            </div>
          </motion.div>
        ))}
      </AnimatePresence>
    </div>
  )
}
```

## Broadcast System (Chat)

### Chat Hook
```tsx
// hooks/useChat.ts
'use client'

import { useEffect, useState } from 'react'
import { createRealtimeClient } from '@/lib/supabase/realtime'
import type { RealtimeChannel } from '@supabase/supabase-js'

interface ChatMessage {
  id: string
  user_id: string
  username: string
  avatar: string
  message: string
  timestamp: string
}

export function useChat(roomId: string = 'main') {
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [channel, setChannel] = useState<RealtimeChannel | null>(null)
  
  useEffect(() => {
    const { createChannel } = createRealtimeClient()
    const newChannel = createChannel(`chat:${roomId}`)
    
    newChannel
      .on('broadcast', { event: 'message' }, ({ payload }) => {
        setMessages(prev => [...prev, payload as ChatMessage])
      })
      .subscribe()
    
    setChannel(newChannel)
    
    return () => {
      newChannel.unsubscribe()
    }
  }, [roomId])
  
  const sendMessage = (message: Omit<ChatMessage, 'id' | 'timestamp'>) => {
    if (channel) {
      const fullMessage: ChatMessage = {
        ...message,
        id: crypto.randomUUID(),
        timestamp: new Date().toISOString()
      }
      
      channel.send({
        type: 'broadcast',
        event: 'message',
        payload: fullMessage
      })
    }
  }
  
  return { messages, sendMessage }
}
```

### Chat Component
```tsx
// components/features/Chat.tsx
'use client'

import { useState, useRef, useEffect } from 'react'
import { useChat } from '@/hooks/useChat'
import { useUser } from '@/hooks/useUser'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Avatar, AvatarImage, AvatarFallback } from '@/components/ui/avatar'
import { Send, MessageCircle, X } from 'lucide-react'
import { motion, AnimatePresence } from 'framer-motion'

export function Chat() {
  const [isOpen, setIsOpen] = useState(false)
  const [inputValue, setInputValue] = useState('')
  const { messages, sendMessage } = useChat()
  const { user } = useUser()
  const scrollRef = useRef<HTMLDivElement>(null)
  
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight
    }
  }, [messages])
  
  const handleSend = () => {
    if (!inputValue.trim() || !user) return
    
    sendMessage({
      user_id: user.id,
      username: user.username,
      avatar: user.avatar,
      message: inputValue.trim()
    })
    
    setInputValue('')
  }
  
  return (
    <div className="fixed bottom-4 right-4 z-40">
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ opacity: 0, y: 20, scale: 0.95 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: 20, scale: 0.95 }}
            className="mb-4"
          >
            <Card className="w-80 h-96">
              <CardHeader className="pb-2">
                <div className="flex items-center justify-between">
                  <CardTitle className="text-sm">Live Chat</CardTitle>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setIsOpen(false)}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              </CardHeader>
              <CardContent className="p-0 flex flex-col h-full">
                <ScrollArea className="flex-1 px-4" ref={scrollRef}>
                  <div className="space-y-2 pb-4">
                    {messages.map((message) => (
                      <div key={message.id} className="flex items-start gap-2">
                        <Avatar className="w-6 h-6">
                          <AvatarImage src={message.avatar} />
                          <AvatarFallback className="text-xs">
                            {message.username[0]}
                          </AvatarFallback>
                        </Avatar>
                        <div className="flex-1 min-w-0">
                          <div className="text-xs text-muted-foreground">
                            @{message.username}
                          </div>
                          <div className="text-sm break-words">
                            {message.message}
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </ScrollArea>
                <div className="p-4 border-t">
                  <div className="flex gap-2">
                    <Input
                      placeholder="Type a message..."
                      value={inputValue}
                      onChange={(e) => setInputValue(e.target.value)}
                      onKeyDown={(e) => e.key === 'Enter' && handleSend()}
                      className="flex-1"
                    />
                    <Button size="sm" onClick={handleSend}>
                      <Send className="h-4 w-4" />
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
        )}
      </AnimatePresence>
      
      <Button
        onClick={() => setIsOpen(!isOpen)}
        className="rounded-full w-12 h-12 shadow-lg"
      >
        <MessageCircle className="h-6 w-6" />
      </Button>
    </div>
  )
}
```

## Performance Optimization

### Throttling and Debouncing
```tsx
// Use lodash throttle for cursor updates
import { throttle } from 'lodash'

const throttledUpdate = throttle(updatePresence, 100) // 10fps max

// Use debounce for typing indicators
import { debounce } from 'lodash'

const debouncedTyping = debounce(setTypingStatus, 300)
```

### Memory Management
```tsx
// Always cleanup subscriptions
useEffect(() => {
  const channel = supabase.channel('room')
  
  return () => {
    channel.unsubscribe()
  }
}, [])

// Limit message history
const MAX_MESSAGES = 100
setMessages(prev => prev.slice(-MAX_MESSAGES))
```

### Connection Management
```tsx
// Handle connection states
channel
  .on('system', {}, (payload) => {
    if (payload.extension === 'postgres_changes') {
      console.log('Database connection status:', payload.status)
    }
  })
  .subscribe((status) => {
    if (status === 'SUBSCRIBED') {
      console.log('Connected to realtime')
    }
  })
```

## Security Considerations

### RLS Policies
```sql
-- Enable RLS on chat messages table if storing in DB
ALTER TABLE chat_messages ENABLE ROW LEVEL SECURITY;

-- Users can read all messages
CREATE POLICY "Messages are viewable by everyone" 
ON chat_messages FOR SELECT 
USING (true);

-- Users can only insert their own messages
CREATE POLICY "Users can insert their own messages" 
ON chat_messages FOR INSERT 
WITH CHECK (auth.uid() = user_id);
```

### Rate Limiting
```tsx
// Client-side rate limiting
const rateLimiter = {
  lastSent: 0,
  minInterval: 1000, // 1 second between messages
  
  canSend(): boolean {
    const now = Date.now()
    if (now - this.lastSent < this.minInterval) {
      return false
    }
    this.lastSent = now
    return true
  }
}
```

## Best Practices

### Channel Naming
- Use descriptive prefixes: `presence:main`, `chat:room-1`
- Include room/scope identifiers
- Keep names consistent across the app

### Error Handling
```tsx
channel
  .on('system', {}, (payload) => {
    if (payload.status === 'error') {
      console.error('Realtime error:', payload)
      // Implement reconnection logic
    }
  })
```

### Graceful Degradation
```tsx
// Fallback when realtime is unavailable
const [isRealtimeAvailable, setIsRealtimeAvailable] = useState(true)

// Provide alternative UI when realtime fails
if (!isRealtimeAvailable) {
  return <StaticChatFallback />
}
```

### Testing
- Mock realtime channels in tests
- Test connection/disconnection scenarios
- Verify cleanup on component unmount
- Test with multiple users/tabs

## Integration with Grind Quest

### Layout Integration
```tsx
// app/layout.tsx
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Providers>
          {children}
          <CursorTracker />
          <FloatingHeads />
          <Chat />
        </Providers>
      </body>
    </html>
  )
}
```

### User Context Integration
```tsx
// Ensure realtime features only work for authenticated users
const { user } = useUser()

if (!user) {
  return null // Don't render realtime features for guests
}
```

### Performance Monitoring
```tsx
// Track realtime performance
useEffect(() => {
  const startTime = Date.now()
  
  channel.subscribe((status) => {
    if (status === 'SUBSCRIBED') {
      const connectionTime = Date.now() - startTime
      console.log(`Realtime connected in ${connectionTime}ms`)
    }
  })
}, [])
```
